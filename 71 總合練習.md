# 1. 封裝-成績

#### (1-1) 儲存架構及說明
``` python
   |__<ntub>
   |    |__ m01.py
   |
   |__ p01.py
   
   
1. m01.py的「計算平均」方法:
   (1) 此方法回傳2個資料, 包括「平均成績」及「平均等第」.
   
   (2) 「平均成績」的計算方式:
       [1] 假設學生至少考了1次小考;
   
       [2] 「平均成績」為3次最高小考成績的平均; 
           如果某學生的小考次數不足3次, 則是他所有小考成績的平均.

   (3) 「平均等第」的計算方式:
       [1] 如果「平均成績」為90~100分, 「平均等第」為 'A';       
       [2] 如果「平均成績」為80~89分,  「平均等第」為 'B';       
       [3] 如果「平均成績」為60~79分,  「平均等第」為 'C';       
       [4] 如果「平均成績」為0~59分,   「平均等第」為 'D'.  
```   
   

#### (1-2) m01.py

``` python
#------------------------
# 學生成績 (未完成)
#------------------------
class Score():
    # 建構元, 傳入學號, 小考的list
    def __init__(self, no, scores):

    # 計算平均
    def average(self):
```


#### (1-3) p01.py (已完成)

``` python
# 匯入模組中的類別
from ntub.m01 import Score 

# 儲存多筆成績
scores = []

# 產生物件清單
scores.append(Score('001', [50, 60, 65, 45, 70, 68]))
scores.append(Score('002', [90, 86, 89, 91, 92, 79]))
scores.append(Score('003', [84, 72]))
scores.append(Score('004', [70, 68, 95]))
scores.append(Score('005', [45, 55, 54, 66, 76, 68, 90, 81]))
scores.append(Score('006', [56, 62, 77, 56, 6, 80]))
scores.append(Score('007', [34, 32, 25, 25, 33]))
scores.append(Score('008', [76, 82, 68, 58, 79, 65, 71]))
scores.append(Score('009', [70, 76, 82, 85, 71]))
scores.append(Score('010', [67, 64, 36, 45, 66]))

# 依序取出清單中的物件, 進行處理
total=0
for s in scores:
    avg, rank = s.average()
    total+=avg
    print('項目:{}, 平均成績:{:.2f}, 等第:{}'.format(s.no, avg, rank))  

print('-'*35)
print('總平均成績:{:.2f}'.format(total/len(scores))) 
print('-'*35)   
```


#### (1-4) 執行結果

``` python
項目:001, 平均成績:67.67, 等第:C
項目:002, 平均成績:91.00, 等第:A
項目:003, 平均成績:78.00, 等第:C
項目:004, 平均成績:77.67, 等第:C
項目:005, 平均成績:82.33, 等第:B
項目:006, 平均成績:73.00, 等第:C
項目:007, 平均成績:33.00, 等第:D
項目:008, 平均成績:79.00, 等第:C
項目:009, 平均成績:81.00, 等第:B
項目:010, 平均成績:65.67, 等第:C
-----------------------------------
總平均成績:72.83
-----------------------------------
```



# 2. 靜態方法-排七

#### (1-1) 儲存架構及說明
``` python
   |__<ntub>
   |    |__ m02.py
   |
   |__ p02.py
   
   
1. 排七(接龍)是一種撲克遊戲, 通常是4個人一起玩, 從「7」開始排. 
   玩家輪流出已出現牌的上一張或下一張牌, 如果沒有可接續的牌就蓋一張牌. 
   遊戲結束後計算每個人的蓋牌總點數, 最多點的人就算輸.
   
2. m02.py的「蓋大牌張數」方法:
   計算傳入的「蓋牌的list」中, 共有幾張「J」, 「Q」, 「K」, 並回傳.
   
3. m02.py的「蓋牌總點數」方法:
   (1) 點數的算法:
       'A' : 1點; 
       '2' : 2點;
       '3' : 3點;
       '4' : 4點;
         .
         .
       '10' : 10點;
       'J'  : 11點;
       'Q'  : 12點;
       'K'  : 13點.
       
   (2) 計算傳入的「蓋牌的list」中, 總共有幾點, 並回傳.
```   
   

#### (2-2) m02.py

``` python
#------------------------
# 排七(接龍), 未完成
#------------------------
class Poker():
    points = {'A':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13}

    # 「蓋大牌張數」
    # 傳入蓋牌的list    
    @staticmethod 
    def big(remains):


    # 「蓋牌總點數」
    # 傳入蓋牌的list    
    @staticmethod 
    def points(remains):
```


#### (2-3) p01.py (已完成)

``` python
# 匯入模組中的類別
from ntub.m02 import Poker 

# 儲存多筆「剩下的牌」
pokers = []

# 產生物件清單
pokers.append(('001', ['A', '5', 'J']))
pokers.append(('002', ['K', 'Q', '3', '4']))
pokers.append(('003', ['4', 'A']))
pokers.append(('004', ['9', '10', '10', 'Q']))
pokers.append(('005', ['A', '2']))
pokers.append(('006', []))
pokers.append(('007', ['9']))
pokers.append(('008', ['K', 'J', 'Q', 'Q']))
pokers.append(('009', ['A', 'K']))
pokers.append(('010', ['4', '9']))

# 依序取出清單中的物件, 進行處理
total=0
for p in pokers:
    sc = Poker.points(p[1])
    total+=sc

    print('項目:{}, 蓋大牌張數:{}, 蓋牌總點數:{}'.format(p[0], Poker.big(p[1]), sc))  

print('-'*40)
print('所有剩牌總點數:{}'.format(total)) 
print('-'*40)   
```


#### (2-4) 執行結果

``` python
項目:001, 蓋大牌張數:1, 蓋牌總點數:17
項目:002, 蓋大牌張數:2, 蓋牌總點數:32
項目:003, 蓋大牌張數:0, 蓋牌總點數:5
項目:004, 蓋大牌張數:1, 蓋牌總點數:41
項目:005, 蓋大牌張數:0, 蓋牌總點數:3
項目:006, 蓋大牌張數:0, 蓋牌總點數:0
項目:007, 蓋大牌張數:0, 蓋牌總點數:9
項目:008, 蓋大牌張數:4, 蓋牌總點數:48
項目:009, 蓋大牌張數:1, 蓋牌總點數:14
項目:010, 蓋大牌張數:0, 蓋牌總點數:13
----------------------------------------
所有剩牌總點數:182
----------------------------------------
```

